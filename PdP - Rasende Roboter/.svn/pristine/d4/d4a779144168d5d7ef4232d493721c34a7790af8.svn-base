package interactions;

import java.util.ArrayList;
import java.util.List;
import java.util.Observable;
import java.util.Observer;
import java.util.Stack;

import model.Board;
import model.Box;
import model.Constant;
import model.Constant.BoxType;
import model.Robot;

/**
 * This is the first version of our AI. It tests all the possibility at each
 * step and check if the {@link #mDestination} is reaches. The possibilities are 
 * not yet optimized (all possibilities are analyzed).
 * @author Dimitri
 * @version 1
 */
public class Solver extends Observable implements InterfaceSolver{
	/**
	 * 
	 * @see Board
	 */
	private Board mBoard; // MISTAKE -- Pas forcement utile de stocker le plateau !
	/**
	 * 
	 * @see Robot
	 * @see List
	 */
	private List<Robot> mRobots;
	private Box mDestination;
	private int mDestinationX;
	private int mDestinationY;	
	/**
	 * The probability tree that is constructed during analysis
	 * @see ProbabilityTree
	 */
	private ProbabilityTree mProbabilityTree;
	private Thread mThread = new Thread() {
		public void run() {
			findSolution();
		}
	};

	/**
	 * Call this method to start the method {@link #findSolution()}. All data is copied 
	 * locally. Finally, the method {@link #findSolution()} is called in a new 
	 * {@link Thread}.
	 * @param board the current board of the game
	 * @param robots a list of the current position of the robots
	 * @param destination the box that the player must reach
	 * @see #findSolution()
	 * @see Board
	 * @see Robot
	 * @see Box
	 * @see List
	 * @see Thread
	 */
	public void startFindSolution(Board board, List<Robot> robots,
			Box destination) {
		this.mBoard = board;
		this.mDestination = destination;
		this.mRobots = new ArrayList<Robot>(robots);

		this.findCoordDestination(destination);
		
		if(mThread.isInterrupted())
			mThread.interrupt();
		
		mThread.start();
	}

	/**
	 * Search where is the box that the robot must reached. It's call before 
	 * {@link #findSolution()}
	 * @param destination
	 */
	private void findCoordDestination(Box destination){
		for (int i = 0; i < Constant.numberOfcase; i++) {
			for (int j = 0; j < Constant.numberOfcase; j++) {
				if(mBoard.getBox()[i][j].getType() == destination.getType()
						&& mBoard.getBox()[i][j].getColor() == destination.getColor()
						|| mBoard.getBox()[i][j].getType() == destination.getType()
						&& destination.getType() == BoxType.Multi){
					mDestinationX = i;
					mDestinationY = j;
					return;
				}
			}
		}
		System.err.println("Sould never happend ! No destination find on the board !");		
	}

	/**
	 * Call this method when the solver notify to the observer that he find a solution
	 * @return a Stack of the solution that the IA find
	 * @see model.Event
	 * @see Stack
	 * @see Stack#peek() 
	 */
	public Stack<Event> getSolution() {
		Stack<Event> solution = new Stack<Event>();
		return solution;
	}

	public static int cptCalc = 0;
	
	/**
	 * This method is the heart of the IA. It tests all the possibility at each
	 * step and check if the {@link #mDestination} is reaches.
	 * When the {@link #mDestination} is reached, all {@link Observer} are notify.
	 * @exception OutOfMemoryError if the probability tree is too large
	 * @see Observer#notifyAll()
	 */
	protected void findSolution(){
		System.out.println("In Solver : start findingSolution");	

		this.mProbabilityTree = new ProbabilityTree(new Event(this.mRobots));

		int cpt = 1;

		try {
			while(!mProbabilityTree.finish(this.mDestination, this.mDestinationX, this.mDestinationY)){
				System.out.println("Step(s) : " + cpt++);
				mProbabilityTree.spread(mBoard);
				System.out.println("Compute(s) : " + cptCalc);
				cptCalc = 0;
			}
		} catch (OutOfMemoryError e) {
			System.out.println("OutOfMemory ! :(");
		}
	}

	@Override
	public void notifyObservers() {
		// TODO Auto-generated method stub
		
	}
}
