package interactions;

import java.util.List;
import java.util.Observer;
import java.util.Stack;

import model.Board;
import model.Box;
import model.Constant;
import model.Constant.BoxType;
import model.Constant.Direction;
import model.Robot;
import model.Movement;
import model.Constant.Color;

/**
 * This is the first version of our AI. It tests all the possibility at each
 * step and check if the {@link #mDestination} is reaches. The possibilities are 
 * not yet optimized (all possibilities are analyzed).
 * @author Dimitri
 * @version 1
 */
public class Solver extends AbstractAI {
	/**
	 * 
	 * @see Board
	 */
	private Board mBoard; // MISTAKE -- Pas forcement utile de stocker le plateau !
	/**
	 * 
	 * @see Robot
	 * @see List
	 */
	private List<Robot> mRobots;
	private Box mDestination;
	private int mDestinationX;
	private int mDestinationY;	
	/**
	 * The probability tree that is constructed during analysis
	 * @see ProbabilityTree
	 */
	private ProbabilityTree mProbabilityTree;

	/**
	 * Call this method to start the method {@link #findSolution()}. All data is copied 
	 * locally. Finally, the method {@link #findSolution()} is called in a new 
	 * {@link Thread}.
	 * @param board the current board of the game
	 * @param robots a list of the current position of the robots
	 * @param destination the box that the player must reach
	 * @see #findSolution()
	 * @see Board
	 * @see Robot
	 * @see Box
	 * @see List
	 * @see Thread
	 */
	public void startFindSolution(Board board, List<Robot> robots,
			Box destination) {
		this.mBoard = board;
		this.mRobots = robots;
		this.mDestination = destination;
		
		this.findCoordDestination(destination);

		Thread thread = new Thread() {
			public void run() {
				findSolution();
			}
		};
		thread.start();
	}

	/**
	 * 
	 * @param destination
	 */
	private void findCoordDestination(Box destination){
		for (int i = 0; i < mBoard.getPlateau_size(); i++) {
			for (int j = 0; j < mBoard.getPlateau_size(); j++) {
				if(mBoard.getBox()[i][j].getType() == destination.getType()
						&& mBoard.getBox()[i][j].getColor() == destination.getColor()
						|| mBoard.getBox()[i][j].getType() == destination.getType()
								&& destination.getType() == BoxType.Multi){
					mDestinationX = i;
					mDestinationY = j;
					//System.out.println("New destination : x -> " + mDestinationX + " ; y -> " + mDestinationY);
					return;
				}
			}
		}
		System.err.println("Sould never happend ! No destination find on the board !");		
	}
	
	/**
	 * Call this method when the IA notify to the observer that he find a solution
	 * @return a Stack of the solution that the IA find
	 * @see model.Event
	 * @see Stack
	 * @see Stack#peek() 
	 */
	public Stack<Event> getSolution() {
		Stack<Event> solution = new Stack<Event>();
		solution.push(getLastMovement());
		/*
		while(solution.peek().mFather != null){
			solution.push(solution.peek().mFather);
		}
		*/
		return solution;
	}

	/**
	 * Called to start building the solution
	 * @return the event that has reached the solution 
	 */
	private Event getLastMovement() {
		return null;
	}

	/**
	 * This method is the heart of the IA. It tests all the possibility at each
	 * step and check if the {@link #mDestination} is reaches.
	 * When the {@link #mDestination} is reached, all {@link Observer} are notify.
	 * @exception OutOfMemoryError if the probability tree is too large
	 * @see Observer#notifyAll()
	 */
	protected void findSolution() throws OutOfMemoryError{
		this.mProbabilityTree = new ProbabilityTree(null);
		System.out.println("In Solver : start findingSolution");		
		
		
		
		for(Robot robot : mRobots) {
			System.out.println("Robot " + robot.getColor() + " : x -> " + robot.x + " ; y -> " + robot.y);
			for (Direction direction : Direction.values()) {				
				Robot r = mBoard.getNewPosition(robot, direction, mRobots);
				Event mEvent = new Event(mRobots, new Movement(direction, r));
				
				//System.out.println("Robot " + r.getColor() + " : x -> " + r.x + " ; y -> " + r.y);
				if(mEvent.reachedDestination(mDestination, mDestinationX, mDestinationY))
					System.out.println("Solution trouvée !!!!");
			}
		}
	}
}
