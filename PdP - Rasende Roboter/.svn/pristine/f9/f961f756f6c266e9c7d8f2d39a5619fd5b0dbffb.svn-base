package game;

import game.Constant.BoxType;
import game.Constant.Color;
import game.Constant.Direction;

import java.util.ArrayList;
import java.util.List;
import java.util.Stack;

import solverAlgorithm.Solver;


/**
 * The model of our architecture
 */
public class Game {
	private Board mBoard;
	private List<Robot> mRobots;
	private int mCounterLap;
	private Stack<Robot> mPreviousPosition;
	private Stack<Robot> mNextPosition;
	private Robot mSelectedRobot;
	private Stack<Box> mGoalCard;
	private Solver mSolver;

	/**
	 * Construtor of Model
	 */
	public Game() {
		

	}

	public void startNewGame(){
		generateBoard();
		
		mRobots = new ArrayList<Robot>();
		for(Color c : Constant.Color.values()){
			Robot r = new Robot(c);
			r.placeOnBoard(mRobots);
			mRobots.add(r);
		}	

		mGoalCard = new Stack<Box>();
		
		//Cr�ation d'un tableau qui contient toutes les cartes possibles
		int i = 0;
		Box [] goalCardTab = new Box[17];
		for(Color c : Color.values()){
			for(BoxType bt : BoxType.values()){
				if(bt != BoxType.Central && bt != BoxType.Empty && bt != BoxType.Multi){
					goalCardTab[i] = new Box(bt, c);
					i++;
				}
			}
		}
		goalCardTab[i] = new Box(BoxType.Multi, null);
		
		//Ajout al�atoire des cartes dans la pile
		for (int j = 17; j > 0; j--){
			int k = (int)(Math.random()*100) % j;
			mGoalCard.push(goalCardTab[k]);
			if (k != (j-1)){
				Box tmp = goalCardTab[j-1];
				goalCardTab[j-1] = goalCardTab[k];
				goalCardTab[k] = tmp;
			}
		}
			
		mGoalCard.push(new Box(BoxType.Empty, null));

		startNewLap();
	}

	private void generateBoard() {
		mBoard = new Board();
		mBoard.initboard();
		
	}

	private void startNewLap(){
		if(mGoalCard.empty()) {
			System.out.println("Game Over !");
		}
		else{
			mCounterLap = 0;

			mPreviousPosition = new Stack<Robot>();
			mNextPosition = new Stack<Robot>();

			mGoalCard.pop();
		}
	}

	/**
	 * Getter of gameBoard
	 * @return gameBoard : Board
	 * @see Board
	 */
	public Board getBoard() {
		return mBoard;
	}

	/**
	 * Getter of the robots' list
	 * @return robots : the list of robots
	 * @see Robot
	 * @see List
	 */
	public List<Robot> getRobots() {
		return mRobots;
	}

	/**
	 * Return the robot with the specified Color
	 * @param c : Color, the color of the robot asked
	 * @return r : Robot, if the robot with this color exist, else null
	 * @see Color
	 * @see Robot
	 */
	public Robot getRobot(Color c) {
		for(Robot r : mRobots) {
			if(r.getColor() == c)
				return r;
		}
		return null;
	}

	/**
	 * Setter of the robots' list
	 * @param robots
	 * @see Robot
	 * @see List
	 */
	public void setRobots(List<Robot> robots) {
		mRobots = robots;
	}

	/**
	 * Getter of Current Round
	 * @return currentRound : int
	 */
	public int getCurrentRound(){
		return 17 - mGoalCard.size() + 1;
	}

	public void setRobotByColor(Color color, Robot r) {
		for(int i = 0; i < mRobots.size(); i++) {
            if(mRobots.get(i).getColor() == color) {
                    mRobots.set(i, r);
            }
		}
	}
	
	public void loadPreviousPosition(){
		if(mPreviousPosition == null)
			mPreviousPosition = new Stack<Robot>();

	    if(!mPreviousPosition.empty()) {
            Robot r = mPreviousPosition.pop();
            
            setRobotByColor(r.getColor(), r);
            
            if(mNextPosition == null)
				mNextPosition = new Stack<Robot>();
            
            mNextPosition.push(new Robot(r));
            mCounterLap--;
	    }
	}

	private void saveCurrentPosition(Robot r){
		if(mPreviousPosition == null)
			mPreviousPosition = new Stack<Robot>();
		
		if(!mPreviousPosition.empty()) {
			if(!mPreviousPosition.peek().equals(r)) {
				mPreviousPosition.push(new Robot(r));
			}
		}
		else
			mPreviousPosition.push(new Robot(r));
	}

	public void loadNextPosition(){
		
		if(mNextPosition == null)
			mNextPosition = new Stack<Robot>();

		if(!mNextPosition.empty()) {
            Robot r = mNextPosition.pop();
            
            setRobotByColor(r.getColor(), r);
            
            if(mPreviousPosition == null)
				mPreviousPosition = new Stack<Robot>();
            
            mPreviousPosition.push(new Robot(r));

			mCounterLap++;
		}
	}

	/**
	 * Move a robot in a direction
	 * @param robot : the robot to move
	 * @param direction : Left, Right, Down, Up
	 * @see Direction
	 * @see Robot
	 */
	public void moveSelectedRobot(Direction direction){
		boolean hasMoved;
		
		saveCurrentPosition(mSelectedRobot);
		
		hasMoved = mBoard.getNewPosition(mSelectedRobot, direction, mRobots);
		
		if(hasMoved)
			mCounterLap++;

			if (mBoard.getGameBoard()[mSelectedRobot.y][mSelectedRobot.x].getType() == getGoalCard().getType()
				&&	getGoalCard().getType() == BoxType.Multi){
					// TODO Ajouter un point !!!
					startNewLap();
			}
			else{
				if (mBoard.getGameBoard()[mSelectedRobot.y][mSelectedRobot.x].getType() == getGoalCard().getType()
						&& mBoard.getGameBoard()[mSelectedRobot.y][mSelectedRobot.x].getColor() == getGoalCard().getColor()
						&& mSelectedRobot.getColor() == getGoalCard().getColor()){					
						// TODO Ajouter un point !!!
						startNewLap();
				}
			}
	}

	public Box getGoalCard() {
		if(!mGoalCard.empty())
			return mGoalCard.peek();
		return null;
	}

	public Robot getSelectedRobot() {
		return mSelectedRobot;
	}

	public void setSelectedRobot(Robot selectedRobot) {
		mSelectedRobot = selectedRobot;
	}

	public void setSelectedRobot(Color color){
		for(Robot r : mRobots)
			if(r.getColor() == color)
				mSelectedRobot = r;
	}

	public int getCounterLap(){
		return mCounterLap;
	}

	public void startSolver(){
		if (mSolver == null)
			mSolver = new Solver();
		mSolver.startFindSolution(mBoard, mRobots, getGoalCard());
	}
}